<?php
/**
 * ModWorkshopGetReviewerAssessments200ResponseAssessmentsInner
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Moodle Webservice API
 *
 * Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * ModWorkshopGetReviewerAssessments200ResponseAssessmentsInner Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ModWorkshopGetReviewerAssessments200ResponseAssessmentsInner implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'mod_workshop_get_reviewer_assessments_200_response_assessments_inner';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'feedbackattachmentfiles' => '\OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]',
        'feedbackauthor' => 'string',
        'feedbackauthorattachment' => 'int',
        'feedbackauthorformat' => 'int',
        'feedbackcontentfiles' => '\OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]',
        'feedbackreviewer' => 'string',
        'feedbackreviewerformat' => 'int',
        'grade' => 'float',
        'gradinggrade' => 'float',
        'gradinggradeover' => 'float',
        'gradinggradeoverby' => 'int',
        'id' => 'int',
        'reviewerid' => 'int',
        'submissionid' => 'int',
        'timecreated' => 'int',
        'timemodified' => 'int',
        'weight' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'feedbackattachmentfiles' => null,
        'feedbackauthor' => null,
        'feedbackauthorattachment' => null,
        'feedbackauthorformat' => null,
        'feedbackcontentfiles' => null,
        'feedbackreviewer' => null,
        'feedbackreviewerformat' => null,
        'grade' => null,
        'gradinggrade' => null,
        'gradinggradeover' => null,
        'gradinggradeoverby' => null,
        'id' => null,
        'reviewerid' => null,
        'submissionid' => null,
        'timecreated' => null,
        'timemodified' => null,
        'weight' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'feedbackattachmentfiles' => false,
        'feedbackauthor' => false,
        'feedbackauthorattachment' => false,
        'feedbackauthorformat' => false,
        'feedbackcontentfiles' => false,
        'feedbackreviewer' => false,
        'feedbackreviewerformat' => false,
        'grade' => false,
        'gradinggrade' => false,
        'gradinggradeover' => false,
        'gradinggradeoverby' => false,
        'id' => false,
        'reviewerid' => false,
        'submissionid' => false,
        'timecreated' => false,
        'timemodified' => false,
        'weight' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'feedbackattachmentfiles' => 'feedbackattachmentfiles',
        'feedbackauthor' => 'feedbackauthor',
        'feedbackauthorattachment' => 'feedbackauthorattachment',
        'feedbackauthorformat' => 'feedbackauthorformat',
        'feedbackcontentfiles' => 'feedbackcontentfiles',
        'feedbackreviewer' => 'feedbackreviewer',
        'feedbackreviewerformat' => 'feedbackreviewerformat',
        'grade' => 'grade',
        'gradinggrade' => 'gradinggrade',
        'gradinggradeover' => 'gradinggradeover',
        'gradinggradeoverby' => 'gradinggradeoverby',
        'id' => 'id',
        'reviewerid' => 'reviewerid',
        'submissionid' => 'submissionid',
        'timecreated' => 'timecreated',
        'timemodified' => 'timemodified',
        'weight' => 'weight'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'feedbackattachmentfiles' => 'setFeedbackattachmentfiles',
        'feedbackauthor' => 'setFeedbackauthor',
        'feedbackauthorattachment' => 'setFeedbackauthorattachment',
        'feedbackauthorformat' => 'setFeedbackauthorformat',
        'feedbackcontentfiles' => 'setFeedbackcontentfiles',
        'feedbackreviewer' => 'setFeedbackreviewer',
        'feedbackreviewerformat' => 'setFeedbackreviewerformat',
        'grade' => 'setGrade',
        'gradinggrade' => 'setGradinggrade',
        'gradinggradeover' => 'setGradinggradeover',
        'gradinggradeoverby' => 'setGradinggradeoverby',
        'id' => 'setId',
        'reviewerid' => 'setReviewerid',
        'submissionid' => 'setSubmissionid',
        'timecreated' => 'setTimecreated',
        'timemodified' => 'setTimemodified',
        'weight' => 'setWeight'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'feedbackattachmentfiles' => 'getFeedbackattachmentfiles',
        'feedbackauthor' => 'getFeedbackauthor',
        'feedbackauthorattachment' => 'getFeedbackauthorattachment',
        'feedbackauthorformat' => 'getFeedbackauthorformat',
        'feedbackcontentfiles' => 'getFeedbackcontentfiles',
        'feedbackreviewer' => 'getFeedbackreviewer',
        'feedbackreviewerformat' => 'getFeedbackreviewerformat',
        'grade' => 'getGrade',
        'gradinggrade' => 'getGradinggrade',
        'gradinggradeover' => 'getGradinggradeover',
        'gradinggradeoverby' => 'getGradinggradeoverby',
        'id' => 'getId',
        'reviewerid' => 'getReviewerid',
        'submissionid' => 'getSubmissionid',
        'timecreated' => 'getTimecreated',
        'timemodified' => 'getTimemodified',
        'weight' => 'getWeight'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('feedbackattachmentfiles', $data ?? [], null);
        $this->setIfExists('feedbackauthor', $data ?? [], null);
        $this->setIfExists('feedbackauthorattachment', $data ?? [], 0);
        $this->setIfExists('feedbackauthorformat', $data ?? [], 0);
        $this->setIfExists('feedbackcontentfiles', $data ?? [], null);
        $this->setIfExists('feedbackreviewer', $data ?? [], null);
        $this->setIfExists('feedbackreviewerformat', $data ?? [], 0);
        $this->setIfExists('grade', $data ?? [], null);
        $this->setIfExists('gradinggrade', $data ?? [], null);
        $this->setIfExists('gradinggradeover', $data ?? [], null);
        $this->setIfExists('gradinggradeoverby', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('reviewerid', $data ?? [], null);
        $this->setIfExists('submissionid', $data ?? [], null);
        $this->setIfExists('timecreated', $data ?? [], 0);
        $this->setIfExists('timemodified', $data ?? [], 0);
        $this->setIfExists('weight', $data ?? [], 1);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets feedbackattachmentfiles
     *
     * @return \OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]|null
     */
    public function getFeedbackattachmentfiles()
    {
        return $this->container['feedbackattachmentfiles'];
    }

    /**
     * Sets feedbackattachmentfiles
     *
     * @param \OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]|null $feedbackattachmentfiles feedbackattachmentfiles
     *
     * @return self
     */
    public function setFeedbackattachmentfiles($feedbackattachmentfiles)
    {
        if (is_null($feedbackattachmentfiles)) {
            throw new \InvalidArgumentException('non-nullable feedbackattachmentfiles cannot be null');
        }
        $this->container['feedbackattachmentfiles'] = $feedbackattachmentfiles;

        return $this;
    }

    /**
     * Gets feedbackauthor
     *
     * @return string|null
     */
    public function getFeedbackauthor()
    {
        return $this->container['feedbackauthor'];
    }

    /**
     * Sets feedbackauthor
     *
     * @param string|null $feedbackauthor The comment/feedback from the reviewer for the author.
     *
     * @return self
     */
    public function setFeedbackauthor($feedbackauthor)
    {
        if (is_null($feedbackauthor)) {
            throw new \InvalidArgumentException('non-nullable feedbackauthor cannot be null');
        }
        $this->container['feedbackauthor'] = $feedbackauthor;

        return $this;
    }

    /**
     * Gets feedbackauthorattachment
     *
     * @return int|null
     */
    public function getFeedbackauthorattachment()
    {
        return $this->container['feedbackauthorattachment'];
    }

    /**
     * Sets feedbackauthorattachment
     *
     * @param int|null $feedbackauthorattachment Are there some files attached to the feedbackauthor field?                     Sets to 1 by file_postupdate_standard_filemanager().
     *
     * @return self
     */
    public function setFeedbackauthorattachment($feedbackauthorattachment)
    {
        if (is_null($feedbackauthorattachment)) {
            throw new \InvalidArgumentException('non-nullable feedbackauthorattachment cannot be null');
        }
        $this->container['feedbackauthorattachment'] = $feedbackauthorattachment;

        return $this;
    }

    /**
     * Gets feedbackauthorformat
     *
     * @return int|null
     */
    public function getFeedbackauthorformat()
    {
        return $this->container['feedbackauthorformat'];
    }

    /**
     * Sets feedbackauthorformat
     *
     * @param int|null $feedbackauthorformat feedbackauthor format (1 = HTML, 0 = MOODLE, 2 = PLAIN, or 4 = MARKDOWN)
     *
     * @return self
     */
    public function setFeedbackauthorformat($feedbackauthorformat)
    {
        if (is_null($feedbackauthorformat)) {
            throw new \InvalidArgumentException('non-nullable feedbackauthorformat cannot be null');
        }
        $this->container['feedbackauthorformat'] = $feedbackauthorformat;

        return $this;
    }

    /**
     * Gets feedbackcontentfiles
     *
     * @return \OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]|null
     */
    public function getFeedbackcontentfiles()
    {
        return $this->container['feedbackcontentfiles'];
    }

    /**
     * Sets feedbackcontentfiles
     *
     * @param \OpenAPI\Client\Model\CoreBlogGetEntries200ResponseEntriesInnerSummaryfilesInner[]|null $feedbackcontentfiles feedbackcontentfiles
     *
     * @return self
     */
    public function setFeedbackcontentfiles($feedbackcontentfiles)
    {
        if (is_null($feedbackcontentfiles)) {
            throw new \InvalidArgumentException('non-nullable feedbackcontentfiles cannot be null');
        }
        $this->container['feedbackcontentfiles'] = $feedbackcontentfiles;

        return $this;
    }

    /**
     * Gets feedbackreviewer
     *
     * @return string|null
     */
    public function getFeedbackreviewer()
    {
        return $this->container['feedbackreviewer'];
    }

    /**
     * Sets feedbackreviewer
     *
     * @param string|null $feedbackreviewer The comment/feedback from the teacher for the reviewer.                     For example the reason why the grade for assessment was overridden
     *
     * @return self
     */
    public function setFeedbackreviewer($feedbackreviewer)
    {
        if (is_null($feedbackreviewer)) {
            throw new \InvalidArgumentException('non-nullable feedbackreviewer cannot be null');
        }
        $this->container['feedbackreviewer'] = $feedbackreviewer;

        return $this;
    }

    /**
     * Gets feedbackreviewerformat
     *
     * @return int|null
     */
    public function getFeedbackreviewerformat()
    {
        return $this->container['feedbackreviewerformat'];
    }

    /**
     * Sets feedbackreviewerformat
     *
     * @param int|null $feedbackreviewerformat feedbackreviewer format (1 = HTML, 0 = MOODLE, 2 = PLAIN, or 4 = MARKDOWN)
     *
     * @return self
     */
    public function setFeedbackreviewerformat($feedbackreviewerformat)
    {
        if (is_null($feedbackreviewerformat)) {
            throw new \InvalidArgumentException('non-nullable feedbackreviewerformat cannot be null');
        }
        $this->container['feedbackreviewerformat'] = $feedbackreviewerformat;

        return $this;
    }

    /**
     * Gets grade
     *
     * @return float|null
     */
    public function getGrade()
    {
        return $this->container['grade'];
    }

    /**
     * Sets grade
     *
     * @param float|null $grade The aggregated grade for submission suggested by the reviewer.                     The grade 0..100 is computed from the values assigned to the assessment dimensions fields. If NULL then it has not been aggregated yet.
     *
     * @return self
     */
    public function setGrade($grade)
    {
        if (is_null($grade)) {
            throw new \InvalidArgumentException('non-nullable grade cannot be null');
        }
        $this->container['grade'] = $grade;

        return $this;
    }

    /**
     * Gets gradinggrade
     *
     * @return float|null
     */
    public function getGradinggrade()
    {
        return $this->container['gradinggrade'];
    }

    /**
     * Sets gradinggrade
     *
     * @param float|null $gradinggrade The computed grade 0..100 for this assessment. If NULL then it has not been computed yet.
     *
     * @return self
     */
    public function setGradinggrade($gradinggrade)
    {
        if (is_null($gradinggrade)) {
            throw new \InvalidArgumentException('non-nullable gradinggrade cannot be null');
        }
        $this->container['gradinggrade'] = $gradinggrade;

        return $this;
    }

    /**
     * Gets gradinggradeover
     *
     * @return float|null
     */
    public function getGradinggradeover()
    {
        return $this->container['gradinggradeover'];
    }

    /**
     * Sets gradinggradeover
     *
     * @param float|null $gradinggradeover Grade for the assessment manually overridden by a teacher.                     Grade is always from interval 0..100. If NULL then the grade is not overriden.
     *
     * @return self
     */
    public function setGradinggradeover($gradinggradeover)
    {
        if (is_null($gradinggradeover)) {
            throw new \InvalidArgumentException('non-nullable gradinggradeover cannot be null');
        }
        $this->container['gradinggradeover'] = $gradinggradeover;

        return $this;
    }

    /**
     * Gets gradinggradeoverby
     *
     * @return int|null
     */
    public function getGradinggradeoverby()
    {
        return $this->container['gradinggradeoverby'];
    }

    /**
     * Sets gradinggradeoverby
     *
     * @param int|null $gradinggradeoverby The id of the user who has overridden the grade for submission.
     *
     * @return self
     */
    public function setGradinggradeoverby($gradinggradeoverby)
    {
        if (is_null($gradinggradeoverby)) {
            throw new \InvalidArgumentException('non-nullable gradinggradeoverby cannot be null');
        }
        $this->container['gradinggradeoverby'] = $gradinggradeoverby;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id The primary key of the record.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets reviewerid
     *
     * @return int|null
     */
    public function getReviewerid()
    {
        return $this->container['reviewerid'];
    }

    /**
     * Sets reviewerid
     *
     * @param int|null $reviewerid The id of the reviewer who makes this assessment
     *
     * @return self
     */
    public function setReviewerid($reviewerid)
    {
        if (is_null($reviewerid)) {
            throw new \InvalidArgumentException('non-nullable reviewerid cannot be null');
        }
        $this->container['reviewerid'] = $reviewerid;

        return $this;
    }

    /**
     * Gets submissionid
     *
     * @return int|null
     */
    public function getSubmissionid()
    {
        return $this->container['submissionid'];
    }

    /**
     * Sets submissionid
     *
     * @param int|null $submissionid The id of the assessed submission
     *
     * @return self
     */
    public function setSubmissionid($submissionid)
    {
        if (is_null($submissionid)) {
            throw new \InvalidArgumentException('non-nullable submissionid cannot be null');
        }
        $this->container['submissionid'] = $submissionid;

        return $this;
    }

    /**
     * Gets timecreated
     *
     * @return int|null
     */
    public function getTimecreated()
    {
        return $this->container['timecreated'];
    }

    /**
     * Sets timecreated
     *
     * @param int|null $timecreated If 0 then the assessment was allocated but the reviewer has not assessed yet.                     If greater than 0 then the timestamp of when the reviewer assessed for the first time
     *
     * @return self
     */
    public function setTimecreated($timecreated)
    {
        if (is_null($timecreated)) {
            throw new \InvalidArgumentException('non-nullable timecreated cannot be null');
        }
        $this->container['timecreated'] = $timecreated;

        return $this;
    }

    /**
     * Gets timemodified
     *
     * @return int|null
     */
    public function getTimemodified()
    {
        return $this->container['timemodified'];
    }

    /**
     * Sets timemodified
     *
     * @param int|null $timemodified If 0 then the assessment was allocated but the reviewer has not assessed yet.                     If greater than 0 then the timestamp of when the reviewer assessed for the last time
     *
     * @return self
     */
    public function setTimemodified($timemodified)
    {
        if (is_null($timemodified)) {
            throw new \InvalidArgumentException('non-nullable timemodified cannot be null');
        }
        $this->container['timemodified'] = $timemodified;

        return $this;
    }

    /**
     * Gets weight
     *
     * @return int|null
     */
    public function getWeight()
    {
        return $this->container['weight'];
    }

    /**
     * Sets weight
     *
     * @param int|null $weight The weight of the assessment for the purposes of aggregation
     *
     * @return self
     */
    public function setWeight($weight)
    {
        if (is_null($weight)) {
            throw new \InvalidArgumentException('non-nullable weight cannot be null');
        }
        $this->container['weight'] = $weight;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


