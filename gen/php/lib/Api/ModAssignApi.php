<?php
/**
 * ModAssignApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Moodle Webservice API
 *
 * Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ModAssignApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ModAssignApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'modAssignCopyPreviousAttempt' => [
            'application/json',
        ],
        'modAssignGetAssignments' => [
            'application/json',
        ],
        'modAssignGetGrades' => [
            'application/json',
        ],
        'modAssignGetParticipant' => [
            'application/json',
        ],
        'modAssignGetSubmissionStatus' => [
            'application/json',
        ],
        'modAssignGetSubmissions' => [
            'application/json',
        ],
        'modAssignGetUserFlags' => [
            'application/json',
        ],
        'modAssignGetUserMappings' => [
            'application/json',
        ],
        'modAssignListParticipants' => [
            'application/json',
        ],
        'modAssignLockSubmissions' => [
            'application/json',
        ],
        'modAssignRevealIdentities' => [
            'application/json',
        ],
        'modAssignRevertSubmissionsToDraft' => [
            'application/json',
        ],
        'modAssignSaveGrade' => [
            'application/json',
        ],
        'modAssignSaveGrades' => [
            'application/json',
        ],
        'modAssignSaveSubmission' => [
            'application/json',
        ],
        'modAssignSaveUserExtensions' => [
            'application/json',
        ],
        'modAssignSetUserFlags' => [
            'application/json',
        ],
        'modAssignStartSubmission' => [
            'application/json',
        ],
        'modAssignSubmitForGrading' => [
            'application/json',
        ],
        'modAssignSubmitGradingForm' => [
            'application/json',
        ],
        'modAssignUnlockSubmissions' => [
            'application/json',
        ],
        'modAssignViewAssign' => [
            'application/json',
        ],
        'modAssignViewGradingTable' => [
            'application/json',
        ],
        'modAssignViewSubmissionStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation modAssignCopyPreviousAttempt
     *
     * Copy a students previous attempt to a new attempt.
     *
     * @param  \OpenAPI\Client\Model\ModAssignCopyPreviousAttemptRequest $mod_assign_copy_previous_attempt_request mod_assign_copy_previous_attempt_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignCopyPreviousAttempt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignCopyPreviousAttempt($mod_assign_copy_previous_attempt_request, string $contentType = self::contentTypes['modAssignCopyPreviousAttempt'][0])
    {
        list($response) = $this->modAssignCopyPreviousAttemptWithHttpInfo($mod_assign_copy_previous_attempt_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignCopyPreviousAttemptWithHttpInfo
     *
     * Copy a students previous attempt to a new attempt.
     *
     * @param  \OpenAPI\Client\Model\ModAssignCopyPreviousAttemptRequest $mod_assign_copy_previous_attempt_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignCopyPreviousAttempt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignCopyPreviousAttemptWithHttpInfo($mod_assign_copy_previous_attempt_request, string $contentType = self::contentTypes['modAssignCopyPreviousAttempt'][0])
    {
        $request = $this->modAssignCopyPreviousAttemptRequest($mod_assign_copy_previous_attempt_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignCopyPreviousAttemptAsync
     *
     * Copy a students previous attempt to a new attempt.
     *
     * @param  \OpenAPI\Client\Model\ModAssignCopyPreviousAttemptRequest $mod_assign_copy_previous_attempt_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignCopyPreviousAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignCopyPreviousAttemptAsync($mod_assign_copy_previous_attempt_request, string $contentType = self::contentTypes['modAssignCopyPreviousAttempt'][0])
    {
        return $this->modAssignCopyPreviousAttemptAsyncWithHttpInfo($mod_assign_copy_previous_attempt_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignCopyPreviousAttemptAsyncWithHttpInfo
     *
     * Copy a students previous attempt to a new attempt.
     *
     * @param  \OpenAPI\Client\Model\ModAssignCopyPreviousAttemptRequest $mod_assign_copy_previous_attempt_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignCopyPreviousAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignCopyPreviousAttemptAsyncWithHttpInfo($mod_assign_copy_previous_attempt_request, string $contentType = self::contentTypes['modAssignCopyPreviousAttempt'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignCopyPreviousAttemptRequest($mod_assign_copy_previous_attempt_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignCopyPreviousAttempt'
     *
     * @param  \OpenAPI\Client\Model\ModAssignCopyPreviousAttemptRequest $mod_assign_copy_previous_attempt_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignCopyPreviousAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignCopyPreviousAttemptRequest($mod_assign_copy_previous_attempt_request, string $contentType = self::contentTypes['modAssignCopyPreviousAttempt'][0])
    {

        // verify the required parameter 'mod_assign_copy_previous_attempt_request' is set
        if ($mod_assign_copy_previous_attempt_request === null || (is_array($mod_assign_copy_previous_attempt_request) && count($mod_assign_copy_previous_attempt_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_copy_previous_attempt_request when calling modAssignCopyPreviousAttempt'
            );
        }


        $resourcePath = '/mod_assign_copy_previous_attempt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_copy_previous_attempt_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_copy_previous_attempt_request));
            } else {
                $httpBody = $mod_assign_copy_previous_attempt_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetAssignments
     *
     * Returns the courses and assignments for the users capability
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetAssignmentsRequest $mod_assign_get_assignments_request mod_assign_get_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetAssignments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetAssignments200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetAssignments($mod_assign_get_assignments_request, string $contentType = self::contentTypes['modAssignGetAssignments'][0])
    {
        list($response) = $this->modAssignGetAssignmentsWithHttpInfo($mod_assign_get_assignments_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetAssignmentsWithHttpInfo
     *
     * Returns the courses and assignments for the users capability
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetAssignmentsRequest $mod_assign_get_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetAssignments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetAssignments200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetAssignmentsWithHttpInfo($mod_assign_get_assignments_request, string $contentType = self::contentTypes['modAssignGetAssignments'][0])
    {
        $request = $this->modAssignGetAssignmentsRequest($mod_assign_get_assignments_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetAssignments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetAssignments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetAssignments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetAssignments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetAssignments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetAssignmentsAsync
     *
     * Returns the courses and assignments for the users capability
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetAssignmentsRequest $mod_assign_get_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetAssignmentsAsync($mod_assign_get_assignments_request, string $contentType = self::contentTypes['modAssignGetAssignments'][0])
    {
        return $this->modAssignGetAssignmentsAsyncWithHttpInfo($mod_assign_get_assignments_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetAssignmentsAsyncWithHttpInfo
     *
     * Returns the courses and assignments for the users capability
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetAssignmentsRequest $mod_assign_get_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetAssignmentsAsyncWithHttpInfo($mod_assign_get_assignments_request, string $contentType = self::contentTypes['modAssignGetAssignments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetAssignments200Response';
        $request = $this->modAssignGetAssignmentsRequest($mod_assign_get_assignments_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetAssignments'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetAssignmentsRequest $mod_assign_get_assignments_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetAssignments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetAssignmentsRequest($mod_assign_get_assignments_request, string $contentType = self::contentTypes['modAssignGetAssignments'][0])
    {

        // verify the required parameter 'mod_assign_get_assignments_request' is set
        if ($mod_assign_get_assignments_request === null || (is_array($mod_assign_get_assignments_request) && count($mod_assign_get_assignments_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_assignments_request when calling modAssignGetAssignments'
            );
        }


        $resourcePath = '/mod_assign_get_assignments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_assignments_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_assignments_request));
            } else {
                $httpBody = $mod_assign_get_assignments_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetGrades
     *
     * Returns grades from the assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetGradesRequest $mod_assign_get_grades_request mod_assign_get_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetGrades'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetGrades200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetGrades($mod_assign_get_grades_request, string $contentType = self::contentTypes['modAssignGetGrades'][0])
    {
        list($response) = $this->modAssignGetGradesWithHttpInfo($mod_assign_get_grades_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetGradesWithHttpInfo
     *
     * Returns grades from the assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetGradesRequest $mod_assign_get_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetGrades'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetGrades200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetGradesWithHttpInfo($mod_assign_get_grades_request, string $contentType = self::contentTypes['modAssignGetGrades'][0])
    {
        $request = $this->modAssignGetGradesRequest($mod_assign_get_grades_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetGrades200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetGrades200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetGrades200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetGrades200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetGrades200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetGradesAsync
     *
     * Returns grades from the assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetGradesRequest $mod_assign_get_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetGradesAsync($mod_assign_get_grades_request, string $contentType = self::contentTypes['modAssignGetGrades'][0])
    {
        return $this->modAssignGetGradesAsyncWithHttpInfo($mod_assign_get_grades_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetGradesAsyncWithHttpInfo
     *
     * Returns grades from the assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetGradesRequest $mod_assign_get_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetGradesAsyncWithHttpInfo($mod_assign_get_grades_request, string $contentType = self::contentTypes['modAssignGetGrades'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetGrades200Response';
        $request = $this->modAssignGetGradesRequest($mod_assign_get_grades_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetGrades'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetGradesRequest $mod_assign_get_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetGradesRequest($mod_assign_get_grades_request, string $contentType = self::contentTypes['modAssignGetGrades'][0])
    {

        // verify the required parameter 'mod_assign_get_grades_request' is set
        if ($mod_assign_get_grades_request === null || (is_array($mod_assign_get_grades_request) && count($mod_assign_get_grades_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_grades_request when calling modAssignGetGrades'
            );
        }


        $resourcePath = '/mod_assign_get_grades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_grades_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_grades_request));
            } else {
                $httpBody = $mod_assign_get_grades_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetParticipant
     *
     * Get a participant for an assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetParticipantRequest $mod_assign_get_participant_request mod_assign_get_participant_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetParticipant'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetParticipant200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetParticipant($mod_assign_get_participant_request, string $contentType = self::contentTypes['modAssignGetParticipant'][0])
    {
        list($response) = $this->modAssignGetParticipantWithHttpInfo($mod_assign_get_participant_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetParticipantWithHttpInfo
     *
     * Get a participant for an assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetParticipantRequest $mod_assign_get_participant_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetParticipant'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetParticipant200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetParticipantWithHttpInfo($mod_assign_get_participant_request, string $contentType = self::contentTypes['modAssignGetParticipant'][0])
    {
        $request = $this->modAssignGetParticipantRequest($mod_assign_get_participant_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetParticipant200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetParticipant200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetParticipant200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetParticipant200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetParticipant200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetParticipantAsync
     *
     * Get a participant for an assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetParticipantRequest $mod_assign_get_participant_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetParticipantAsync($mod_assign_get_participant_request, string $contentType = self::contentTypes['modAssignGetParticipant'][0])
    {
        return $this->modAssignGetParticipantAsyncWithHttpInfo($mod_assign_get_participant_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetParticipantAsyncWithHttpInfo
     *
     * Get a participant for an assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetParticipantRequest $mod_assign_get_participant_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetParticipantAsyncWithHttpInfo($mod_assign_get_participant_request, string $contentType = self::contentTypes['modAssignGetParticipant'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetParticipant200Response';
        $request = $this->modAssignGetParticipantRequest($mod_assign_get_participant_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetParticipant'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetParticipantRequest $mod_assign_get_participant_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetParticipant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetParticipantRequest($mod_assign_get_participant_request, string $contentType = self::contentTypes['modAssignGetParticipant'][0])
    {

        // verify the required parameter 'mod_assign_get_participant_request' is set
        if ($mod_assign_get_participant_request === null || (is_array($mod_assign_get_participant_request) && count($mod_assign_get_participant_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_participant_request when calling modAssignGetParticipant'
            );
        }


        $resourcePath = '/mod_assign_get_participant';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_participant_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_participant_request));
            } else {
                $httpBody = $mod_assign_get_participant_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetSubmissionStatus
     *
     * Returns information about an assignment submission status for a given user.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionStatusRequest $mod_assign_get_submission_status_request mod_assign_get_submission_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetSubmissionStatus($mod_assign_get_submission_status_request, string $contentType = self::contentTypes['modAssignGetSubmissionStatus'][0])
    {
        list($response) = $this->modAssignGetSubmissionStatusWithHttpInfo($mod_assign_get_submission_status_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetSubmissionStatusWithHttpInfo
     *
     * Returns information about an assignment submission status for a given user.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionStatusRequest $mod_assign_get_submission_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetSubmissionStatusWithHttpInfo($mod_assign_get_submission_status_request, string $contentType = self::contentTypes['modAssignGetSubmissionStatus'][0])
    {
        $request = $this->modAssignGetSubmissionStatusRequest($mod_assign_get_submission_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetSubmissionStatusAsync
     *
     * Returns information about an assignment submission status for a given user.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionStatusRequest $mod_assign_get_submission_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetSubmissionStatusAsync($mod_assign_get_submission_status_request, string $contentType = self::contentTypes['modAssignGetSubmissionStatus'][0])
    {
        return $this->modAssignGetSubmissionStatusAsyncWithHttpInfo($mod_assign_get_submission_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetSubmissionStatusAsyncWithHttpInfo
     *
     * Returns information about an assignment submission status for a given user.
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionStatusRequest $mod_assign_get_submission_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetSubmissionStatusAsyncWithHttpInfo($mod_assign_get_submission_status_request, string $contentType = self::contentTypes['modAssignGetSubmissionStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetSubmissionStatus200Response';
        $request = $this->modAssignGetSubmissionStatusRequest($mod_assign_get_submission_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetSubmissionStatus'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionStatusRequest $mod_assign_get_submission_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetSubmissionStatusRequest($mod_assign_get_submission_status_request, string $contentType = self::contentTypes['modAssignGetSubmissionStatus'][0])
    {

        // verify the required parameter 'mod_assign_get_submission_status_request' is set
        if ($mod_assign_get_submission_status_request === null || (is_array($mod_assign_get_submission_status_request) && count($mod_assign_get_submission_status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_submission_status_request when calling modAssignGetSubmissionStatus'
            );
        }


        $resourcePath = '/mod_assign_get_submission_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_submission_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_submission_status_request));
            } else {
                $httpBody = $mod_assign_get_submission_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetSubmissions
     *
     * Returns the submissions for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionsRequest $mod_assign_get_submissions_request mod_assign_get_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetSubmissions200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetSubmissions($mod_assign_get_submissions_request, string $contentType = self::contentTypes['modAssignGetSubmissions'][0])
    {
        list($response) = $this->modAssignGetSubmissionsWithHttpInfo($mod_assign_get_submissions_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetSubmissionsWithHttpInfo
     *
     * Returns the submissions for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionsRequest $mod_assign_get_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetSubmissions200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetSubmissionsWithHttpInfo($mod_assign_get_submissions_request, string $contentType = self::contentTypes['modAssignGetSubmissions'][0])
    {
        $request = $this->modAssignGetSubmissionsRequest($mod_assign_get_submissions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetSubmissions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetSubmissions200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetSubmissions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetSubmissions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetSubmissions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetSubmissionsAsync
     *
     * Returns the submissions for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionsRequest $mod_assign_get_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetSubmissionsAsync($mod_assign_get_submissions_request, string $contentType = self::contentTypes['modAssignGetSubmissions'][0])
    {
        return $this->modAssignGetSubmissionsAsyncWithHttpInfo($mod_assign_get_submissions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetSubmissionsAsyncWithHttpInfo
     *
     * Returns the submissions for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionsRequest $mod_assign_get_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetSubmissionsAsyncWithHttpInfo($mod_assign_get_submissions_request, string $contentType = self::contentTypes['modAssignGetSubmissions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetSubmissions200Response';
        $request = $this->modAssignGetSubmissionsRequest($mod_assign_get_submissions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetSubmissions'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetSubmissionsRequest $mod_assign_get_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetSubmissionsRequest($mod_assign_get_submissions_request, string $contentType = self::contentTypes['modAssignGetSubmissions'][0])
    {

        // verify the required parameter 'mod_assign_get_submissions_request' is set
        if ($mod_assign_get_submissions_request === null || (is_array($mod_assign_get_submissions_request) && count($mod_assign_get_submissions_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_submissions_request when calling modAssignGetSubmissions'
            );
        }


        $resourcePath = '/mod_assign_get_submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_submissions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_submissions_request));
            } else {
                $httpBody = $mod_assign_get_submissions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetUserFlags
     *
     * Returns the user flags for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserFlags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetUserFlags200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetUserFlags($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserFlags'][0])
    {
        list($response) = $this->modAssignGetUserFlagsWithHttpInfo($mod_assign_get_user_flags_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetUserFlagsWithHttpInfo
     *
     * Returns the user flags for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserFlags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetUserFlags200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetUserFlagsWithHttpInfo($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserFlags'][0])
    {
        $request = $this->modAssignGetUserFlagsRequest($mod_assign_get_user_flags_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetUserFlags200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetUserFlags200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetUserFlags200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetUserFlags200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetUserFlags200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetUserFlagsAsync
     *
     * Returns the user flags for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetUserFlagsAsync($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserFlags'][0])
    {
        return $this->modAssignGetUserFlagsAsyncWithHttpInfo($mod_assign_get_user_flags_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetUserFlagsAsyncWithHttpInfo
     *
     * Returns the user flags for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetUserFlagsAsyncWithHttpInfo($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserFlags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetUserFlags200Response';
        $request = $this->modAssignGetUserFlagsRequest($mod_assign_get_user_flags_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetUserFlags'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetUserFlagsRequest($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserFlags'][0])
    {

        // verify the required parameter 'mod_assign_get_user_flags_request' is set
        if ($mod_assign_get_user_flags_request === null || (is_array($mod_assign_get_user_flags_request) && count($mod_assign_get_user_flags_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_user_flags_request when calling modAssignGetUserFlags'
            );
        }


        $resourcePath = '/mod_assign_get_user_flags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_user_flags_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_user_flags_request));
            } else {
                $httpBody = $mod_assign_get_user_flags_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignGetUserMappings
     *
     * Returns the blind marking mappings for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserMappings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignGetUserMappings200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignGetUserMappings($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserMappings'][0])
    {
        list($response) = $this->modAssignGetUserMappingsWithHttpInfo($mod_assign_get_user_flags_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignGetUserMappingsWithHttpInfo
     *
     * Returns the blind marking mappings for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserMappings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignGetUserMappings200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignGetUserMappingsWithHttpInfo($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserMappings'][0])
    {
        $request = $this->modAssignGetUserMappingsRequest($mod_assign_get_user_flags_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignGetUserMappings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignGetUserMappings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignGetUserMappings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignGetUserMappings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignGetUserMappings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignGetUserMappingsAsync
     *
     * Returns the blind marking mappings for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserMappings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetUserMappingsAsync($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserMappings'][0])
    {
        return $this->modAssignGetUserMappingsAsyncWithHttpInfo($mod_assign_get_user_flags_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignGetUserMappingsAsyncWithHttpInfo
     *
     * Returns the blind marking mappings for assignments
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserMappings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignGetUserMappingsAsyncWithHttpInfo($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserMappings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignGetUserMappings200Response';
        $request = $this->modAssignGetUserMappingsRequest($mod_assign_get_user_flags_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignGetUserMappings'
     *
     * @param  \OpenAPI\Client\Model\ModAssignGetUserFlagsRequest $mod_assign_get_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignGetUserMappings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignGetUserMappingsRequest($mod_assign_get_user_flags_request, string $contentType = self::contentTypes['modAssignGetUserMappings'][0])
    {

        // verify the required parameter 'mod_assign_get_user_flags_request' is set
        if ($mod_assign_get_user_flags_request === null || (is_array($mod_assign_get_user_flags_request) && count($mod_assign_get_user_flags_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_get_user_flags_request when calling modAssignGetUserMappings'
            );
        }


        $resourcePath = '/mod_assign_get_user_mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_get_user_flags_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_get_user_flags_request));
            } else {
                $httpBody = $mod_assign_get_user_flags_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignListParticipants
     *
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignListParticipantsRequest $mod_assign_list_participants_request mod_assign_list_participants_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignListParticipants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignListParticipants($mod_assign_list_participants_request, string $contentType = self::contentTypes['modAssignListParticipants'][0])
    {
        list($response) = $this->modAssignListParticipantsWithHttpInfo($mod_assign_list_participants_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignListParticipantsWithHttpInfo
     *
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignListParticipantsRequest $mod_assign_list_participants_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignListParticipants'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignListParticipantsWithHttpInfo($mod_assign_list_participants_request, string $contentType = self::contentTypes['modAssignListParticipants'][0])
    {
        $request = $this->modAssignListParticipantsRequest($mod_assign_list_participants_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignListParticipantsAsync
     *
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignListParticipantsRequest $mod_assign_list_participants_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignListParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignListParticipantsAsync($mod_assign_list_participants_request, string $contentType = self::contentTypes['modAssignListParticipants'][0])
    {
        return $this->modAssignListParticipantsAsyncWithHttpInfo($mod_assign_list_participants_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignListParticipantsAsyncWithHttpInfo
     *
     * List the participants for a single assignment, with some summary info about their submissions.
     *
     * @param  \OpenAPI\Client\Model\ModAssignListParticipantsRequest $mod_assign_list_participants_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignListParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignListParticipantsAsyncWithHttpInfo($mod_assign_list_participants_request, string $contentType = self::contentTypes['modAssignListParticipants'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignListParticipantsRequest($mod_assign_list_participants_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignListParticipants'
     *
     * @param  \OpenAPI\Client\Model\ModAssignListParticipantsRequest $mod_assign_list_participants_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignListParticipants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignListParticipantsRequest($mod_assign_list_participants_request, string $contentType = self::contentTypes['modAssignListParticipants'][0])
    {

        // verify the required parameter 'mod_assign_list_participants_request' is set
        if ($mod_assign_list_participants_request === null || (is_array($mod_assign_list_participants_request) && count($mod_assign_list_participants_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_list_participants_request when calling modAssignListParticipants'
            );
        }


        $resourcePath = '/mod_assign_list_participants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_list_participants_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_list_participants_request));
            } else {
                $httpBody = $mod_assign_list_participants_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignLockSubmissions
     *
     * Prevent students from making changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignLockSubmissionsRequest $mod_assign_lock_submissions_request mod_assign_lock_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignLockSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignLockSubmissions($mod_assign_lock_submissions_request, string $contentType = self::contentTypes['modAssignLockSubmissions'][0])
    {
        list($response) = $this->modAssignLockSubmissionsWithHttpInfo($mod_assign_lock_submissions_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignLockSubmissionsWithHttpInfo
     *
     * Prevent students from making changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignLockSubmissionsRequest $mod_assign_lock_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignLockSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignLockSubmissionsWithHttpInfo($mod_assign_lock_submissions_request, string $contentType = self::contentTypes['modAssignLockSubmissions'][0])
    {
        $request = $this->modAssignLockSubmissionsRequest($mod_assign_lock_submissions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignLockSubmissionsAsync
     *
     * Prevent students from making changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignLockSubmissionsRequest $mod_assign_lock_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignLockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignLockSubmissionsAsync($mod_assign_lock_submissions_request, string $contentType = self::contentTypes['modAssignLockSubmissions'][0])
    {
        return $this->modAssignLockSubmissionsAsyncWithHttpInfo($mod_assign_lock_submissions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignLockSubmissionsAsyncWithHttpInfo
     *
     * Prevent students from making changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignLockSubmissionsRequest $mod_assign_lock_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignLockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignLockSubmissionsAsyncWithHttpInfo($mod_assign_lock_submissions_request, string $contentType = self::contentTypes['modAssignLockSubmissions'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignLockSubmissionsRequest($mod_assign_lock_submissions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignLockSubmissions'
     *
     * @param  \OpenAPI\Client\Model\ModAssignLockSubmissionsRequest $mod_assign_lock_submissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignLockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignLockSubmissionsRequest($mod_assign_lock_submissions_request, string $contentType = self::contentTypes['modAssignLockSubmissions'][0])
    {

        // verify the required parameter 'mod_assign_lock_submissions_request' is set
        if ($mod_assign_lock_submissions_request === null || (is_array($mod_assign_lock_submissions_request) && count($mod_assign_lock_submissions_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_lock_submissions_request when calling modAssignLockSubmissions'
            );
        }


        $resourcePath = '/mod_assign_lock_submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_lock_submissions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_lock_submissions_request));
            } else {
                $httpBody = $mod_assign_lock_submissions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignRevealIdentities
     *
     * Reveal the identities for a blind marking assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevealIdentitiesRequest $mod_assign_reveal_identities_request mod_assign_reveal_identities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevealIdentities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignRevealIdentities($mod_assign_reveal_identities_request, string $contentType = self::contentTypes['modAssignRevealIdentities'][0])
    {
        list($response) = $this->modAssignRevealIdentitiesWithHttpInfo($mod_assign_reveal_identities_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignRevealIdentitiesWithHttpInfo
     *
     * Reveal the identities for a blind marking assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevealIdentitiesRequest $mod_assign_reveal_identities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevealIdentities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignRevealIdentitiesWithHttpInfo($mod_assign_reveal_identities_request, string $contentType = self::contentTypes['modAssignRevealIdentities'][0])
    {
        $request = $this->modAssignRevealIdentitiesRequest($mod_assign_reveal_identities_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignRevealIdentitiesAsync
     *
     * Reveal the identities for a blind marking assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevealIdentitiesRequest $mod_assign_reveal_identities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevealIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignRevealIdentitiesAsync($mod_assign_reveal_identities_request, string $contentType = self::contentTypes['modAssignRevealIdentities'][0])
    {
        return $this->modAssignRevealIdentitiesAsyncWithHttpInfo($mod_assign_reveal_identities_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignRevealIdentitiesAsyncWithHttpInfo
     *
     * Reveal the identities for a blind marking assignment
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevealIdentitiesRequest $mod_assign_reveal_identities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevealIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignRevealIdentitiesAsyncWithHttpInfo($mod_assign_reveal_identities_request, string $contentType = self::contentTypes['modAssignRevealIdentities'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignRevealIdentitiesRequest($mod_assign_reveal_identities_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignRevealIdentities'
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevealIdentitiesRequest $mod_assign_reveal_identities_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevealIdentities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignRevealIdentitiesRequest($mod_assign_reveal_identities_request, string $contentType = self::contentTypes['modAssignRevealIdentities'][0])
    {

        // verify the required parameter 'mod_assign_reveal_identities_request' is set
        if ($mod_assign_reveal_identities_request === null || (is_array($mod_assign_reveal_identities_request) && count($mod_assign_reveal_identities_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_reveal_identities_request when calling modAssignRevealIdentities'
            );
        }


        $resourcePath = '/mod_assign_reveal_identities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_reveal_identities_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_reveal_identities_request));
            } else {
                $httpBody = $mod_assign_reveal_identities_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignRevertSubmissionsToDraft
     *
     * Reverts the list of submissions to draft status
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevertSubmissionsToDraft'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignRevertSubmissionsToDraft($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignRevertSubmissionsToDraft'][0])
    {
        list($response) = $this->modAssignRevertSubmissionsToDraftWithHttpInfo($mod_assign_revert_submissions_to_draft_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignRevertSubmissionsToDraftWithHttpInfo
     *
     * Reverts the list of submissions to draft status
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevertSubmissionsToDraft'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignRevertSubmissionsToDraftWithHttpInfo($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignRevertSubmissionsToDraft'][0])
    {
        $request = $this->modAssignRevertSubmissionsToDraftRequest($mod_assign_revert_submissions_to_draft_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignRevertSubmissionsToDraftAsync
     *
     * Reverts the list of submissions to draft status
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevertSubmissionsToDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignRevertSubmissionsToDraftAsync($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignRevertSubmissionsToDraft'][0])
    {
        return $this->modAssignRevertSubmissionsToDraftAsyncWithHttpInfo($mod_assign_revert_submissions_to_draft_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignRevertSubmissionsToDraftAsyncWithHttpInfo
     *
     * Reverts the list of submissions to draft status
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevertSubmissionsToDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignRevertSubmissionsToDraftAsyncWithHttpInfo($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignRevertSubmissionsToDraft'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignRevertSubmissionsToDraftRequest($mod_assign_revert_submissions_to_draft_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignRevertSubmissionsToDraft'
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignRevertSubmissionsToDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignRevertSubmissionsToDraftRequest($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignRevertSubmissionsToDraft'][0])
    {

        // verify the required parameter 'mod_assign_revert_submissions_to_draft_request' is set
        if ($mod_assign_revert_submissions_to_draft_request === null || (is_array($mod_assign_revert_submissions_to_draft_request) && count($mod_assign_revert_submissions_to_draft_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_revert_submissions_to_draft_request when calling modAssignRevertSubmissionsToDraft'
            );
        }


        $resourcePath = '/mod_assign_revert_submissions_to_draft';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_revert_submissions_to_draft_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_revert_submissions_to_draft_request));
            } else {
                $httpBody = $mod_assign_revert_submissions_to_draft_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSaveGrade
     *
     * Save a grade update for a single student.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradeRequest $mod_assign_save_grade_request mod_assign_save_grade_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrade'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSaveGrade($mod_assign_save_grade_request, string $contentType = self::contentTypes['modAssignSaveGrade'][0])
    {
        list($response) = $this->modAssignSaveGradeWithHttpInfo($mod_assign_save_grade_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSaveGradeWithHttpInfo
     *
     * Save a grade update for a single student.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradeRequest $mod_assign_save_grade_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrade'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSaveGradeWithHttpInfo($mod_assign_save_grade_request, string $contentType = self::contentTypes['modAssignSaveGrade'][0])
    {
        $request = $this->modAssignSaveGradeRequest($mod_assign_save_grade_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSaveGradeAsync
     *
     * Save a grade update for a single student.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradeRequest $mod_assign_save_grade_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrade'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveGradeAsync($mod_assign_save_grade_request, string $contentType = self::contentTypes['modAssignSaveGrade'][0])
    {
        return $this->modAssignSaveGradeAsyncWithHttpInfo($mod_assign_save_grade_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSaveGradeAsyncWithHttpInfo
     *
     * Save a grade update for a single student.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradeRequest $mod_assign_save_grade_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrade'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveGradeAsyncWithHttpInfo($mod_assign_save_grade_request, string $contentType = self::contentTypes['modAssignSaveGrade'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSaveGradeRequest($mod_assign_save_grade_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSaveGrade'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradeRequest $mod_assign_save_grade_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrade'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSaveGradeRequest($mod_assign_save_grade_request, string $contentType = self::contentTypes['modAssignSaveGrade'][0])
    {

        // verify the required parameter 'mod_assign_save_grade_request' is set
        if ($mod_assign_save_grade_request === null || (is_array($mod_assign_save_grade_request) && count($mod_assign_save_grade_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_save_grade_request when calling modAssignSaveGrade'
            );
        }


        $resourcePath = '/mod_assign_save_grade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_save_grade_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_save_grade_request));
            } else {
                $httpBody = $mod_assign_save_grade_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSaveGrades
     *
     * Save multiple grade updates for an assignment.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradesRequest $mod_assign_save_grades_request mod_assign_save_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrades'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSaveGrades($mod_assign_save_grades_request, string $contentType = self::contentTypes['modAssignSaveGrades'][0])
    {
        list($response) = $this->modAssignSaveGradesWithHttpInfo($mod_assign_save_grades_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSaveGradesWithHttpInfo
     *
     * Save multiple grade updates for an assignment.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradesRequest $mod_assign_save_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrades'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSaveGradesWithHttpInfo($mod_assign_save_grades_request, string $contentType = self::contentTypes['modAssignSaveGrades'][0])
    {
        $request = $this->modAssignSaveGradesRequest($mod_assign_save_grades_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSaveGradesAsync
     *
     * Save multiple grade updates for an assignment.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradesRequest $mod_assign_save_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveGradesAsync($mod_assign_save_grades_request, string $contentType = self::contentTypes['modAssignSaveGrades'][0])
    {
        return $this->modAssignSaveGradesAsyncWithHttpInfo($mod_assign_save_grades_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSaveGradesAsyncWithHttpInfo
     *
     * Save multiple grade updates for an assignment.
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradesRequest $mod_assign_save_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveGradesAsyncWithHttpInfo($mod_assign_save_grades_request, string $contentType = self::contentTypes['modAssignSaveGrades'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSaveGradesRequest($mod_assign_save_grades_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSaveGrades'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveGradesRequest $mod_assign_save_grades_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveGrades'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSaveGradesRequest($mod_assign_save_grades_request, string $contentType = self::contentTypes['modAssignSaveGrades'][0])
    {

        // verify the required parameter 'mod_assign_save_grades_request' is set
        if ($mod_assign_save_grades_request === null || (is_array($mod_assign_save_grades_request) && count($mod_assign_save_grades_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_save_grades_request when calling modAssignSaveGrades'
            );
        }


        $resourcePath = '/mod_assign_save_grades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_save_grades_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_save_grades_request));
            } else {
                $httpBody = $mod_assign_save_grades_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSaveSubmission
     *
     * Update the current students submission
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveSubmissionRequest $mod_assign_save_submission_request mod_assign_save_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSaveSubmission($mod_assign_save_submission_request, string $contentType = self::contentTypes['modAssignSaveSubmission'][0])
    {
        list($response) = $this->modAssignSaveSubmissionWithHttpInfo($mod_assign_save_submission_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSaveSubmissionWithHttpInfo
     *
     * Update the current students submission
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveSubmissionRequest $mod_assign_save_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSaveSubmissionWithHttpInfo($mod_assign_save_submission_request, string $contentType = self::contentTypes['modAssignSaveSubmission'][0])
    {
        $request = $this->modAssignSaveSubmissionRequest($mod_assign_save_submission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSaveSubmissionAsync
     *
     * Update the current students submission
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveSubmissionRequest $mod_assign_save_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveSubmissionAsync($mod_assign_save_submission_request, string $contentType = self::contentTypes['modAssignSaveSubmission'][0])
    {
        return $this->modAssignSaveSubmissionAsyncWithHttpInfo($mod_assign_save_submission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSaveSubmissionAsyncWithHttpInfo
     *
     * Update the current students submission
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveSubmissionRequest $mod_assign_save_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveSubmissionAsyncWithHttpInfo($mod_assign_save_submission_request, string $contentType = self::contentTypes['modAssignSaveSubmission'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSaveSubmissionRequest($mod_assign_save_submission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSaveSubmission'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveSubmissionRequest $mod_assign_save_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSaveSubmissionRequest($mod_assign_save_submission_request, string $contentType = self::contentTypes['modAssignSaveSubmission'][0])
    {

        // verify the required parameter 'mod_assign_save_submission_request' is set
        if ($mod_assign_save_submission_request === null || (is_array($mod_assign_save_submission_request) && count($mod_assign_save_submission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_save_submission_request when calling modAssignSaveSubmission'
            );
        }


        $resourcePath = '/mod_assign_save_submission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_save_submission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_save_submission_request));
            } else {
                $httpBody = $mod_assign_save_submission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSaveUserExtensions
     *
     * Save a list of assignment extensions
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveUserExtensionsRequest $mod_assign_save_user_extensions_request mod_assign_save_user_extensions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveUserExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSaveUserExtensions($mod_assign_save_user_extensions_request, string $contentType = self::contentTypes['modAssignSaveUserExtensions'][0])
    {
        list($response) = $this->modAssignSaveUserExtensionsWithHttpInfo($mod_assign_save_user_extensions_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSaveUserExtensionsWithHttpInfo
     *
     * Save a list of assignment extensions
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveUserExtensionsRequest $mod_assign_save_user_extensions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveUserExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSaveUserExtensionsWithHttpInfo($mod_assign_save_user_extensions_request, string $contentType = self::contentTypes['modAssignSaveUserExtensions'][0])
    {
        $request = $this->modAssignSaveUserExtensionsRequest($mod_assign_save_user_extensions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSaveUserExtensionsAsync
     *
     * Save a list of assignment extensions
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveUserExtensionsRequest $mod_assign_save_user_extensions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveUserExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveUserExtensionsAsync($mod_assign_save_user_extensions_request, string $contentType = self::contentTypes['modAssignSaveUserExtensions'][0])
    {
        return $this->modAssignSaveUserExtensionsAsyncWithHttpInfo($mod_assign_save_user_extensions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSaveUserExtensionsAsyncWithHttpInfo
     *
     * Save a list of assignment extensions
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveUserExtensionsRequest $mod_assign_save_user_extensions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveUserExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSaveUserExtensionsAsyncWithHttpInfo($mod_assign_save_user_extensions_request, string $contentType = self::contentTypes['modAssignSaveUserExtensions'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSaveUserExtensionsRequest($mod_assign_save_user_extensions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSaveUserExtensions'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSaveUserExtensionsRequest $mod_assign_save_user_extensions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSaveUserExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSaveUserExtensionsRequest($mod_assign_save_user_extensions_request, string $contentType = self::contentTypes['modAssignSaveUserExtensions'][0])
    {

        // verify the required parameter 'mod_assign_save_user_extensions_request' is set
        if ($mod_assign_save_user_extensions_request === null || (is_array($mod_assign_save_user_extensions_request) && count($mod_assign_save_user_extensions_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_save_user_extensions_request when calling modAssignSaveUserExtensions'
            );
        }


        $resourcePath = '/mod_assign_save_user_extensions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_save_user_extensions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_save_user_extensions_request));
            } else {
                $httpBody = $mod_assign_save_user_extensions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSetUserFlags
     *
     * Creates or updates user flags
     *
     * @param  \OpenAPI\Client\Model\ModAssignSetUserFlagsRequest $mod_assign_set_user_flags_request mod_assign_set_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSetUserFlags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSetUserFlags($mod_assign_set_user_flags_request, string $contentType = self::contentTypes['modAssignSetUserFlags'][0])
    {
        list($response) = $this->modAssignSetUserFlagsWithHttpInfo($mod_assign_set_user_flags_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSetUserFlagsWithHttpInfo
     *
     * Creates or updates user flags
     *
     * @param  \OpenAPI\Client\Model\ModAssignSetUserFlagsRequest $mod_assign_set_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSetUserFlags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSetUserFlagsWithHttpInfo($mod_assign_set_user_flags_request, string $contentType = self::contentTypes['modAssignSetUserFlags'][0])
    {
        $request = $this->modAssignSetUserFlagsRequest($mod_assign_set_user_flags_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSetUserFlagsAsync
     *
     * Creates or updates user flags
     *
     * @param  \OpenAPI\Client\Model\ModAssignSetUserFlagsRequest $mod_assign_set_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSetUserFlagsAsync($mod_assign_set_user_flags_request, string $contentType = self::contentTypes['modAssignSetUserFlags'][0])
    {
        return $this->modAssignSetUserFlagsAsyncWithHttpInfo($mod_assign_set_user_flags_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSetUserFlagsAsyncWithHttpInfo
     *
     * Creates or updates user flags
     *
     * @param  \OpenAPI\Client\Model\ModAssignSetUserFlagsRequest $mod_assign_set_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSetUserFlagsAsyncWithHttpInfo($mod_assign_set_user_flags_request, string $contentType = self::contentTypes['modAssignSetUserFlags'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSetUserFlagsRequest($mod_assign_set_user_flags_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSetUserFlags'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSetUserFlagsRequest $mod_assign_set_user_flags_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSetUserFlags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSetUserFlagsRequest($mod_assign_set_user_flags_request, string $contentType = self::contentTypes['modAssignSetUserFlags'][0])
    {

        // verify the required parameter 'mod_assign_set_user_flags_request' is set
        if ($mod_assign_set_user_flags_request === null || (is_array($mod_assign_set_user_flags_request) && count($mod_assign_set_user_flags_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_set_user_flags_request when calling modAssignSetUserFlags'
            );
        }


        $resourcePath = '/mod_assign_set_user_flags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_set_user_flags_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_set_user_flags_request));
            } else {
                $httpBody = $mod_assign_set_user_flags_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignStartSubmission
     *
     * Start a submission for user if assignment has a time limit.
     *
     * @param  \OpenAPI\Client\Model\ModAssignStartSubmissionRequest $mod_assign_start_submission_request mod_assign_start_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignStartSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModAssignStartSubmission200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignStartSubmission($mod_assign_start_submission_request, string $contentType = self::contentTypes['modAssignStartSubmission'][0])
    {
        list($response) = $this->modAssignStartSubmissionWithHttpInfo($mod_assign_start_submission_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignStartSubmissionWithHttpInfo
     *
     * Start a submission for user if assignment has a time limit.
     *
     * @param  \OpenAPI\Client\Model\ModAssignStartSubmissionRequest $mod_assign_start_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignStartSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModAssignStartSubmission200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignStartSubmissionWithHttpInfo($mod_assign_start_submission_request, string $contentType = self::contentTypes['modAssignStartSubmission'][0])
    {
        $request = $this->modAssignStartSubmissionRequest($mod_assign_start_submission_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModAssignStartSubmission200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModAssignStartSubmission200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModAssignStartSubmission200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModAssignStartSubmission200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModAssignStartSubmission200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignStartSubmissionAsync
     *
     * Start a submission for user if assignment has a time limit.
     *
     * @param  \OpenAPI\Client\Model\ModAssignStartSubmissionRequest $mod_assign_start_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignStartSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignStartSubmissionAsync($mod_assign_start_submission_request, string $contentType = self::contentTypes['modAssignStartSubmission'][0])
    {
        return $this->modAssignStartSubmissionAsyncWithHttpInfo($mod_assign_start_submission_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignStartSubmissionAsyncWithHttpInfo
     *
     * Start a submission for user if assignment has a time limit.
     *
     * @param  \OpenAPI\Client\Model\ModAssignStartSubmissionRequest $mod_assign_start_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignStartSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignStartSubmissionAsyncWithHttpInfo($mod_assign_start_submission_request, string $contentType = self::contentTypes['modAssignStartSubmission'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModAssignStartSubmission200Response';
        $request = $this->modAssignStartSubmissionRequest($mod_assign_start_submission_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignStartSubmission'
     *
     * @param  \OpenAPI\Client\Model\ModAssignStartSubmissionRequest $mod_assign_start_submission_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignStartSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignStartSubmissionRequest($mod_assign_start_submission_request, string $contentType = self::contentTypes['modAssignStartSubmission'][0])
    {

        // verify the required parameter 'mod_assign_start_submission_request' is set
        if ($mod_assign_start_submission_request === null || (is_array($mod_assign_start_submission_request) && count($mod_assign_start_submission_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_start_submission_request when calling modAssignStartSubmission'
            );
        }


        $resourcePath = '/mod_assign_start_submission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_start_submission_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_start_submission_request));
            } else {
                $httpBody = $mod_assign_start_submission_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSubmitForGrading
     *
     * Submit the current students assignment for grading
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitForGradingRequest $mod_assign_submit_for_grading_request mod_assign_submit_for_grading_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitForGrading'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSubmitForGrading($mod_assign_submit_for_grading_request, string $contentType = self::contentTypes['modAssignSubmitForGrading'][0])
    {
        list($response) = $this->modAssignSubmitForGradingWithHttpInfo($mod_assign_submit_for_grading_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSubmitForGradingWithHttpInfo
     *
     * Submit the current students assignment for grading
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitForGradingRequest $mod_assign_submit_for_grading_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitForGrading'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSubmitForGradingWithHttpInfo($mod_assign_submit_for_grading_request, string $contentType = self::contentTypes['modAssignSubmitForGrading'][0])
    {
        $request = $this->modAssignSubmitForGradingRequest($mod_assign_submit_for_grading_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSubmitForGradingAsync
     *
     * Submit the current students assignment for grading
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitForGradingRequest $mod_assign_submit_for_grading_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitForGrading'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSubmitForGradingAsync($mod_assign_submit_for_grading_request, string $contentType = self::contentTypes['modAssignSubmitForGrading'][0])
    {
        return $this->modAssignSubmitForGradingAsyncWithHttpInfo($mod_assign_submit_for_grading_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSubmitForGradingAsyncWithHttpInfo
     *
     * Submit the current students assignment for grading
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitForGradingRequest $mod_assign_submit_for_grading_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitForGrading'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSubmitForGradingAsyncWithHttpInfo($mod_assign_submit_for_grading_request, string $contentType = self::contentTypes['modAssignSubmitForGrading'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSubmitForGradingRequest($mod_assign_submit_for_grading_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSubmitForGrading'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitForGradingRequest $mod_assign_submit_for_grading_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitForGrading'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSubmitForGradingRequest($mod_assign_submit_for_grading_request, string $contentType = self::contentTypes['modAssignSubmitForGrading'][0])
    {

        // verify the required parameter 'mod_assign_submit_for_grading_request' is set
        if ($mod_assign_submit_for_grading_request === null || (is_array($mod_assign_submit_for_grading_request) && count($mod_assign_submit_for_grading_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_submit_for_grading_request when calling modAssignSubmitForGrading'
            );
        }


        $resourcePath = '/mod_assign_submit_for_grading';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_submit_for_grading_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_submit_for_grading_request));
            } else {
                $httpBody = $mod_assign_submit_for_grading_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignSubmitGradingForm
     *
     * Submit the grading form data via ajax
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitGradingFormRequest $mod_assign_submit_grading_form_request mod_assign_submit_grading_form_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitGradingForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignSubmitGradingForm($mod_assign_submit_grading_form_request, string $contentType = self::contentTypes['modAssignSubmitGradingForm'][0])
    {
        list($response) = $this->modAssignSubmitGradingFormWithHttpInfo($mod_assign_submit_grading_form_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignSubmitGradingFormWithHttpInfo
     *
     * Submit the grading form data via ajax
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitGradingFormRequest $mod_assign_submit_grading_form_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitGradingForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignSubmitGradingFormWithHttpInfo($mod_assign_submit_grading_form_request, string $contentType = self::contentTypes['modAssignSubmitGradingForm'][0])
    {
        $request = $this->modAssignSubmitGradingFormRequest($mod_assign_submit_grading_form_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignSubmitGradingFormAsync
     *
     * Submit the grading form data via ajax
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitGradingFormRequest $mod_assign_submit_grading_form_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitGradingForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSubmitGradingFormAsync($mod_assign_submit_grading_form_request, string $contentType = self::contentTypes['modAssignSubmitGradingForm'][0])
    {
        return $this->modAssignSubmitGradingFormAsyncWithHttpInfo($mod_assign_submit_grading_form_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignSubmitGradingFormAsyncWithHttpInfo
     *
     * Submit the grading form data via ajax
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitGradingFormRequest $mod_assign_submit_grading_form_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitGradingForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignSubmitGradingFormAsyncWithHttpInfo($mod_assign_submit_grading_form_request, string $contentType = self::contentTypes['modAssignSubmitGradingForm'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignSubmitGradingFormRequest($mod_assign_submit_grading_form_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignSubmitGradingForm'
     *
     * @param  \OpenAPI\Client\Model\ModAssignSubmitGradingFormRequest $mod_assign_submit_grading_form_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignSubmitGradingForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignSubmitGradingFormRequest($mod_assign_submit_grading_form_request, string $contentType = self::contentTypes['modAssignSubmitGradingForm'][0])
    {

        // verify the required parameter 'mod_assign_submit_grading_form_request' is set
        if ($mod_assign_submit_grading_form_request === null || (is_array($mod_assign_submit_grading_form_request) && count($mod_assign_submit_grading_form_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_submit_grading_form_request when calling modAssignSubmitGradingForm'
            );
        }


        $resourcePath = '/mod_assign_submit_grading_form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_submit_grading_form_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_submit_grading_form_request));
            } else {
                $httpBody = $mod_assign_submit_grading_form_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignUnlockSubmissions
     *
     * Allow students to make changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignUnlockSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignUnlockSubmissions($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignUnlockSubmissions'][0])
    {
        list($response) = $this->modAssignUnlockSubmissionsWithHttpInfo($mod_assign_revert_submissions_to_draft_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignUnlockSubmissionsWithHttpInfo
     *
     * Allow students to make changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignUnlockSubmissions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignUnlockSubmissionsWithHttpInfo($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignUnlockSubmissions'][0])
    {
        $request = $this->modAssignUnlockSubmissionsRequest($mod_assign_revert_submissions_to_draft_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignUnlockSubmissionsAsync
     *
     * Allow students to make changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignUnlockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignUnlockSubmissionsAsync($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignUnlockSubmissions'][0])
    {
        return $this->modAssignUnlockSubmissionsAsyncWithHttpInfo($mod_assign_revert_submissions_to_draft_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignUnlockSubmissionsAsyncWithHttpInfo
     *
     * Allow students to make changes to a list of submissions
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignUnlockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignUnlockSubmissionsAsyncWithHttpInfo($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignUnlockSubmissions'][0])
    {
        $returnType = 'object';
        $request = $this->modAssignUnlockSubmissionsRequest($mod_assign_revert_submissions_to_draft_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignUnlockSubmissions'
     *
     * @param  \OpenAPI\Client\Model\ModAssignRevertSubmissionsToDraftRequest $mod_assign_revert_submissions_to_draft_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignUnlockSubmissions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignUnlockSubmissionsRequest($mod_assign_revert_submissions_to_draft_request, string $contentType = self::contentTypes['modAssignUnlockSubmissions'][0])
    {

        // verify the required parameter 'mod_assign_revert_submissions_to_draft_request' is set
        if ($mod_assign_revert_submissions_to_draft_request === null || (is_array($mod_assign_revert_submissions_to_draft_request) && count($mod_assign_revert_submissions_to_draft_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_revert_submissions_to_draft_request when calling modAssignUnlockSubmissions'
            );
        }


        $resourcePath = '/mod_assign_unlock_submissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_revert_submissions_to_draft_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_revert_submissions_to_draft_request));
            } else {
                $httpBody = $mod_assign_revert_submissions_to_draft_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignViewAssign
     *
     * Update the module completion status.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignViewAssign($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewAssign'][0])
    {
        list($response) = $this->modAssignViewAssignWithHttpInfo($mod_assign_view_assign_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignViewAssignWithHttpInfo
     *
     * Update the module completion status.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignViewAssignWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewAssign'][0])
    {
        $request = $this->modAssignViewAssignRequest($mod_assign_view_assign_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignViewAssignAsync
     *
     * Update the module completion status.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewAssignAsync($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewAssign'][0])
    {
        return $this->modAssignViewAssignAsyncWithHttpInfo($mod_assign_view_assign_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignViewAssignAsyncWithHttpInfo
     *
     * Update the module completion status.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewAssignAsyncWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewAssign'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
        $request = $this->modAssignViewAssignRequest($mod_assign_view_assign_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignViewAssign'
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignViewAssignRequest($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewAssign'][0])
    {

        // verify the required parameter 'mod_assign_view_assign_request' is set
        if ($mod_assign_view_assign_request === null || (is_array($mod_assign_view_assign_request) && count($mod_assign_view_assign_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_view_assign_request when calling modAssignViewAssign'
            );
        }


        $resourcePath = '/mod_assign_view_assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_view_assign_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_view_assign_request));
            } else {
                $httpBody = $mod_assign_view_assign_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignViewGradingTable
     *
     * Trigger the grading_table_viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewGradingTable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignViewGradingTable($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewGradingTable'][0])
    {
        list($response) = $this->modAssignViewGradingTableWithHttpInfo($mod_assign_view_assign_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignViewGradingTableWithHttpInfo
     *
     * Trigger the grading_table_viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewGradingTable'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignViewGradingTableWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewGradingTable'][0])
    {
        $request = $this->modAssignViewGradingTableRequest($mod_assign_view_assign_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignViewGradingTableAsync
     *
     * Trigger the grading_table_viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewGradingTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewGradingTableAsync($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewGradingTable'][0])
    {
        return $this->modAssignViewGradingTableAsyncWithHttpInfo($mod_assign_view_assign_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignViewGradingTableAsyncWithHttpInfo
     *
     * Trigger the grading_table_viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewGradingTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewGradingTableAsyncWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewGradingTable'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
        $request = $this->modAssignViewGradingTableRequest($mod_assign_view_assign_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignViewGradingTable'
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewGradingTable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignViewGradingTableRequest($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewGradingTable'][0])
    {

        // verify the required parameter 'mod_assign_view_assign_request' is set
        if ($mod_assign_view_assign_request === null || (is_array($mod_assign_view_assign_request) && count($mod_assign_view_assign_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_view_assign_request when calling modAssignViewGradingTable'
            );
        }


        $resourcePath = '/mod_assign_view_grading_table';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_view_assign_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_view_assign_request));
            } else {
                $httpBody = $mod_assign_view_assign_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modAssignViewSubmissionStatus
     *
     * Trigger the submission status viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modAssignViewSubmissionStatus($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewSubmissionStatus'][0])
    {
        list($response) = $this->modAssignViewSubmissionStatusWithHttpInfo($mod_assign_view_assign_request, $contentType);
        return $response;
    }

    /**
     * Operation modAssignViewSubmissionStatusWithHttpInfo
     *
     * Trigger the submission status viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modAssignViewSubmissionStatusWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewSubmissionStatus'][0])
    {
        $request = $this->modAssignViewSubmissionStatusRequest($mod_assign_view_assign_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modAssignViewSubmissionStatusAsync
     *
     * Trigger the submission status viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewSubmissionStatusAsync($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewSubmissionStatus'][0])
    {
        return $this->modAssignViewSubmissionStatusAsyncWithHttpInfo($mod_assign_view_assign_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modAssignViewSubmissionStatusAsyncWithHttpInfo
     *
     * Trigger the submission status viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modAssignViewSubmissionStatusAsyncWithHttpInfo($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewSubmissionStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
        $request = $this->modAssignViewSubmissionStatusRequest($mod_assign_view_assign_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modAssignViewSubmissionStatus'
     *
     * @param  \OpenAPI\Client\Model\ModAssignViewAssignRequest $mod_assign_view_assign_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modAssignViewSubmissionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modAssignViewSubmissionStatusRequest($mod_assign_view_assign_request, string $contentType = self::contentTypes['modAssignViewSubmissionStatus'][0])
    {

        // verify the required parameter 'mod_assign_view_assign_request' is set
        if ($mod_assign_view_assign_request === null || (is_array($mod_assign_view_assign_request) && count($mod_assign_view_assign_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_assign_view_assign_request when calling modAssignViewSubmissionStatus'
            );
        }


        $resourcePath = '/mod_assign_view_submission_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_assign_view_assign_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_assign_view_assign_request));
            } else {
                $httpBody = $mod_assign_view_assign_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
