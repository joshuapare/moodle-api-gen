<?php
/**
 * ModScormApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Moodle Webservice API
 *
 * Auto-generated OpenAPI spec for Moodle's Webservice API. Requires installation of the Catalyst RESTful API plugin: https://github.com/catalyst/moodle-webservice_restful.
 *
 * The version of the OpenAPI document: 4.3.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ModScormApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ModScormApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'modScormGetScormAccessInformation' => [
            'application/json',
        ],
        'modScormGetScormAttemptCount' => [
            'application/json',
        ],
        'modScormGetScormScoTracks' => [
            'application/json',
        ],
        'modScormGetScormScoes' => [
            'application/json',
        ],
        'modScormGetScormUserData' => [
            'application/json',
        ],
        'modScormGetScormsByCourses' => [
            'application/json',
        ],
        'modScormInsertScormTracks' => [
            'application/json',
        ],
        'modScormLaunchSco' => [
            'application/json',
        ],
        'modScormViewScorm' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation modScormGetScormAccessInformation
     *
     * Return capabilities information for a given scorm.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAccessInformationRequest $mod_scorm_get_scorm_access_information_request mod_scorm_get_scorm_access_information_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAccessInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormAccessInformation($mod_scorm_get_scorm_access_information_request, string $contentType = self::contentTypes['modScormGetScormAccessInformation'][0])
    {
        list($response) = $this->modScormGetScormAccessInformationWithHttpInfo($mod_scorm_get_scorm_access_information_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormAccessInformationWithHttpInfo
     *
     * Return capabilities information for a given scorm.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAccessInformationRequest $mod_scorm_get_scorm_access_information_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAccessInformation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormAccessInformationWithHttpInfo($mod_scorm_get_scorm_access_information_request, string $contentType = self::contentTypes['modScormGetScormAccessInformation'][0])
    {
        $request = $this->modScormGetScormAccessInformationRequest($mod_scorm_get_scorm_access_information_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormAccessInformationAsync
     *
     * Return capabilities information for a given scorm.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAccessInformationRequest $mod_scorm_get_scorm_access_information_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAccessInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormAccessInformationAsync($mod_scorm_get_scorm_access_information_request, string $contentType = self::contentTypes['modScormGetScormAccessInformation'][0])
    {
        return $this->modScormGetScormAccessInformationAsyncWithHttpInfo($mod_scorm_get_scorm_access_information_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormAccessInformationAsyncWithHttpInfo
     *
     * Return capabilities information for a given scorm.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAccessInformationRequest $mod_scorm_get_scorm_access_information_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAccessInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormAccessInformationAsyncWithHttpInfo($mod_scorm_get_scorm_access_information_request, string $contentType = self::contentTypes['modScormGetScormAccessInformation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormAccessInformation200Response';
        $request = $this->modScormGetScormAccessInformationRequest($mod_scorm_get_scorm_access_information_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormAccessInformation'
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAccessInformationRequest $mod_scorm_get_scorm_access_information_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAccessInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormAccessInformationRequest($mod_scorm_get_scorm_access_information_request, string $contentType = self::contentTypes['modScormGetScormAccessInformation'][0])
    {

        // verify the required parameter 'mod_scorm_get_scorm_access_information_request' is set
        if ($mod_scorm_get_scorm_access_information_request === null || (is_array($mod_scorm_get_scorm_access_information_request) && count($mod_scorm_get_scorm_access_information_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_get_scorm_access_information_request when calling modScormGetScormAccessInformation'
            );
        }


        $resourcePath = '/mod_scorm_get_scorm_access_information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_get_scorm_access_information_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_get_scorm_access_information_request));
            } else {
                $httpBody = $mod_scorm_get_scorm_access_information_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormGetScormAttemptCount
     *
     * Return the number of attempts done by a user in the given SCORM.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAttemptCountRequest $mod_scorm_get_scorm_attempt_count_request mod_scorm_get_scorm_attempt_count_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAttemptCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormAttemptCount($mod_scorm_get_scorm_attempt_count_request, string $contentType = self::contentTypes['modScormGetScormAttemptCount'][0])
    {
        list($response) = $this->modScormGetScormAttemptCountWithHttpInfo($mod_scorm_get_scorm_attempt_count_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormAttemptCountWithHttpInfo
     *
     * Return the number of attempts done by a user in the given SCORM.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAttemptCountRequest $mod_scorm_get_scorm_attempt_count_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAttemptCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormAttemptCountWithHttpInfo($mod_scorm_get_scorm_attempt_count_request, string $contentType = self::contentTypes['modScormGetScormAttemptCount'][0])
    {
        $request = $this->modScormGetScormAttemptCountRequest($mod_scorm_get_scorm_attempt_count_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormAttemptCountAsync
     *
     * Return the number of attempts done by a user in the given SCORM.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAttemptCountRequest $mod_scorm_get_scorm_attempt_count_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAttemptCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormAttemptCountAsync($mod_scorm_get_scorm_attempt_count_request, string $contentType = self::contentTypes['modScormGetScormAttemptCount'][0])
    {
        return $this->modScormGetScormAttemptCountAsyncWithHttpInfo($mod_scorm_get_scorm_attempt_count_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormAttemptCountAsyncWithHttpInfo
     *
     * Return the number of attempts done by a user in the given SCORM.
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAttemptCountRequest $mod_scorm_get_scorm_attempt_count_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAttemptCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormAttemptCountAsyncWithHttpInfo($mod_scorm_get_scorm_attempt_count_request, string $contentType = self::contentTypes['modScormGetScormAttemptCount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormAttemptCount200Response';
        $request = $this->modScormGetScormAttemptCountRequest($mod_scorm_get_scorm_attempt_count_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormAttemptCount'
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormAttemptCountRequest $mod_scorm_get_scorm_attempt_count_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormAttemptCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormAttemptCountRequest($mod_scorm_get_scorm_attempt_count_request, string $contentType = self::contentTypes['modScormGetScormAttemptCount'][0])
    {

        // verify the required parameter 'mod_scorm_get_scorm_attempt_count_request' is set
        if ($mod_scorm_get_scorm_attempt_count_request === null || (is_array($mod_scorm_get_scorm_attempt_count_request) && count($mod_scorm_get_scorm_attempt_count_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_get_scorm_attempt_count_request when calling modScormGetScormAttemptCount'
            );
        }


        $resourcePath = '/mod_scorm_get_scorm_attempt_count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_get_scorm_attempt_count_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_get_scorm_attempt_count_request));
            } else {
                $httpBody = $mod_scorm_get_scorm_attempt_count_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormGetScormScoTracks
     *
     * Retrieves SCO tracking data for the given user id and attempt number
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoTracksRequest $mod_scorm_get_scorm_sco_tracks_request mod_scorm_get_scorm_sco_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoTracks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormScoTracks200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormScoTracks($mod_scorm_get_scorm_sco_tracks_request, string $contentType = self::contentTypes['modScormGetScormScoTracks'][0])
    {
        list($response) = $this->modScormGetScormScoTracksWithHttpInfo($mod_scorm_get_scorm_sco_tracks_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormScoTracksWithHttpInfo
     *
     * Retrieves SCO tracking data for the given user id and attempt number
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoTracksRequest $mod_scorm_get_scorm_sco_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoTracks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormScoTracks200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormScoTracksWithHttpInfo($mod_scorm_get_scorm_sco_tracks_request, string $contentType = self::contentTypes['modScormGetScormScoTracks'][0])
    {
        $request = $this->modScormGetScormScoTracksRequest($mod_scorm_get_scorm_sco_tracks_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormScoTracksAsync
     *
     * Retrieves SCO tracking data for the given user id and attempt number
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoTracksRequest $mod_scorm_get_scorm_sco_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormScoTracksAsync($mod_scorm_get_scorm_sco_tracks_request, string $contentType = self::contentTypes['modScormGetScormScoTracks'][0])
    {
        return $this->modScormGetScormScoTracksAsyncWithHttpInfo($mod_scorm_get_scorm_sco_tracks_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormScoTracksAsyncWithHttpInfo
     *
     * Retrieves SCO tracking data for the given user id and attempt number
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoTracksRequest $mod_scorm_get_scorm_sco_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormScoTracksAsyncWithHttpInfo($mod_scorm_get_scorm_sco_tracks_request, string $contentType = self::contentTypes['modScormGetScormScoTracks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormScoTracks200Response';
        $request = $this->modScormGetScormScoTracksRequest($mod_scorm_get_scorm_sco_tracks_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormScoTracks'
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoTracksRequest $mod_scorm_get_scorm_sco_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormScoTracksRequest($mod_scorm_get_scorm_sco_tracks_request, string $contentType = self::contentTypes['modScormGetScormScoTracks'][0])
    {

        // verify the required parameter 'mod_scorm_get_scorm_sco_tracks_request' is set
        if ($mod_scorm_get_scorm_sco_tracks_request === null || (is_array($mod_scorm_get_scorm_sco_tracks_request) && count($mod_scorm_get_scorm_sco_tracks_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_get_scorm_sco_tracks_request when calling modScormGetScormScoTracks'
            );
        }


        $resourcePath = '/mod_scorm_get_scorm_sco_tracks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_get_scorm_sco_tracks_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_get_scorm_sco_tracks_request));
            } else {
                $httpBody = $mod_scorm_get_scorm_sco_tracks_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormGetScormScoes
     *
     * Returns a list containing all the scoes data related to the given scorm id
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoesRequest $mod_scorm_get_scorm_scoes_request mod_scorm_get_scorm_scoes_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormScoes200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormScoes($mod_scorm_get_scorm_scoes_request, string $contentType = self::contentTypes['modScormGetScormScoes'][0])
    {
        list($response) = $this->modScormGetScormScoesWithHttpInfo($mod_scorm_get_scorm_scoes_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormScoesWithHttpInfo
     *
     * Returns a list containing all the scoes data related to the given scorm id
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoesRequest $mod_scorm_get_scorm_scoes_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormScoes200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormScoesWithHttpInfo($mod_scorm_get_scorm_scoes_request, string $contentType = self::contentTypes['modScormGetScormScoes'][0])
    {
        $request = $this->modScormGetScormScoesRequest($mod_scorm_get_scorm_scoes_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormScoes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormScoes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormScoes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormScoes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormScoes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormScoesAsync
     *
     * Returns a list containing all the scoes data related to the given scorm id
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoesRequest $mod_scorm_get_scorm_scoes_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormScoesAsync($mod_scorm_get_scorm_scoes_request, string $contentType = self::contentTypes['modScormGetScormScoes'][0])
    {
        return $this->modScormGetScormScoesAsyncWithHttpInfo($mod_scorm_get_scorm_scoes_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormScoesAsyncWithHttpInfo
     *
     * Returns a list containing all the scoes data related to the given scorm id
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoesRequest $mod_scorm_get_scorm_scoes_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormScoesAsyncWithHttpInfo($mod_scorm_get_scorm_scoes_request, string $contentType = self::contentTypes['modScormGetScormScoes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormScoes200Response';
        $request = $this->modScormGetScormScoesRequest($mod_scorm_get_scorm_scoes_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormScoes'
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormScoesRequest $mod_scorm_get_scorm_scoes_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormScoes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormScoesRequest($mod_scorm_get_scorm_scoes_request, string $contentType = self::contentTypes['modScormGetScormScoes'][0])
    {

        // verify the required parameter 'mod_scorm_get_scorm_scoes_request' is set
        if ($mod_scorm_get_scorm_scoes_request === null || (is_array($mod_scorm_get_scorm_scoes_request) && count($mod_scorm_get_scorm_scoes_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_get_scorm_scoes_request when calling modScormGetScormScoes'
            );
        }


        $resourcePath = '/mod_scorm_get_scorm_scoes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_get_scorm_scoes_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_get_scorm_scoes_request));
            } else {
                $httpBody = $mod_scorm_get_scorm_scoes_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormGetScormUserData
     *
     * Retrieves user tracking and SCO data and default SCORM values
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormUserDataRequest $mod_scorm_get_scorm_user_data_request mod_scorm_get_scorm_user_data_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormUserData'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormUserData200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormUserData($mod_scorm_get_scorm_user_data_request, string $contentType = self::contentTypes['modScormGetScormUserData'][0])
    {
        list($response) = $this->modScormGetScormUserDataWithHttpInfo($mod_scorm_get_scorm_user_data_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormUserDataWithHttpInfo
     *
     * Retrieves user tracking and SCO data and default SCORM values
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormUserDataRequest $mod_scorm_get_scorm_user_data_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormUserData'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormUserData200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormUserDataWithHttpInfo($mod_scorm_get_scorm_user_data_request, string $contentType = self::contentTypes['modScormGetScormUserData'][0])
    {
        $request = $this->modScormGetScormUserDataRequest($mod_scorm_get_scorm_user_data_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormUserData200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormUserData200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormUserData200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormUserData200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormUserData200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormUserDataAsync
     *
     * Retrieves user tracking and SCO data and default SCORM values
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormUserDataRequest $mod_scorm_get_scorm_user_data_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormUserData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormUserDataAsync($mod_scorm_get_scorm_user_data_request, string $contentType = self::contentTypes['modScormGetScormUserData'][0])
    {
        return $this->modScormGetScormUserDataAsyncWithHttpInfo($mod_scorm_get_scorm_user_data_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormUserDataAsyncWithHttpInfo
     *
     * Retrieves user tracking and SCO data and default SCORM values
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormUserDataRequest $mod_scorm_get_scorm_user_data_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormUserData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormUserDataAsyncWithHttpInfo($mod_scorm_get_scorm_user_data_request, string $contentType = self::contentTypes['modScormGetScormUserData'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormUserData200Response';
        $request = $this->modScormGetScormUserDataRequest($mod_scorm_get_scorm_user_data_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormUserData'
     *
     * @param  \OpenAPI\Client\Model\ModScormGetScormUserDataRequest $mod_scorm_get_scorm_user_data_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormUserData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormUserDataRequest($mod_scorm_get_scorm_user_data_request, string $contentType = self::contentTypes['modScormGetScormUserData'][0])
    {

        // verify the required parameter 'mod_scorm_get_scorm_user_data_request' is set
        if ($mod_scorm_get_scorm_user_data_request === null || (is_array($mod_scorm_get_scorm_user_data_request) && count($mod_scorm_get_scorm_user_data_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_get_scorm_user_data_request when calling modScormGetScormUserData'
            );
        }


        $resourcePath = '/mod_scorm_get_scorm_user_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_get_scorm_user_data_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_get_scorm_user_data_request));
            } else {
                $httpBody = $mod_scorm_get_scorm_user_data_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormGetScormsByCourses
     *
     * Returns a list of scorm instances in a provided set of courses, if                             no courses are provided then all the scorm instances the user has access to will be returned.
     *
     * @param  \OpenAPI\Client\Model\ModChatGetChatsByCoursesRequest $mod_chat_get_chats_by_courses_request mod_chat_get_chats_by_courses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormsByCourses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormGetScormsByCourses200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormGetScormsByCourses($mod_chat_get_chats_by_courses_request, string $contentType = self::contentTypes['modScormGetScormsByCourses'][0])
    {
        list($response) = $this->modScormGetScormsByCoursesWithHttpInfo($mod_chat_get_chats_by_courses_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormGetScormsByCoursesWithHttpInfo
     *
     * Returns a list of scorm instances in a provided set of courses, if                             no courses are provided then all the scorm instances the user has access to will be returned.
     *
     * @param  \OpenAPI\Client\Model\ModChatGetChatsByCoursesRequest $mod_chat_get_chats_by_courses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormsByCourses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormGetScormsByCourses200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormGetScormsByCoursesWithHttpInfo($mod_chat_get_chats_by_courses_request, string $contentType = self::contentTypes['modScormGetScormsByCourses'][0])
    {
        $request = $this->modScormGetScormsByCoursesRequest($mod_chat_get_chats_by_courses_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormGetScormsByCoursesAsync
     *
     * Returns a list of scorm instances in a provided set of courses, if                             no courses are provided then all the scorm instances the user has access to will be returned.
     *
     * @param  \OpenAPI\Client\Model\ModChatGetChatsByCoursesRequest $mod_chat_get_chats_by_courses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormsByCourses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormsByCoursesAsync($mod_chat_get_chats_by_courses_request, string $contentType = self::contentTypes['modScormGetScormsByCourses'][0])
    {
        return $this->modScormGetScormsByCoursesAsyncWithHttpInfo($mod_chat_get_chats_by_courses_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormGetScormsByCoursesAsyncWithHttpInfo
     *
     * Returns a list of scorm instances in a provided set of courses, if                             no courses are provided then all the scorm instances the user has access to will be returned.
     *
     * @param  \OpenAPI\Client\Model\ModChatGetChatsByCoursesRequest $mod_chat_get_chats_by_courses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormsByCourses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormGetScormsByCoursesAsyncWithHttpInfo($mod_chat_get_chats_by_courses_request, string $contentType = self::contentTypes['modScormGetScormsByCourses'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormGetScormsByCourses200Response';
        $request = $this->modScormGetScormsByCoursesRequest($mod_chat_get_chats_by_courses_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormGetScormsByCourses'
     *
     * @param  \OpenAPI\Client\Model\ModChatGetChatsByCoursesRequest $mod_chat_get_chats_by_courses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormGetScormsByCourses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormGetScormsByCoursesRequest($mod_chat_get_chats_by_courses_request, string $contentType = self::contentTypes['modScormGetScormsByCourses'][0])
    {

        // verify the required parameter 'mod_chat_get_chats_by_courses_request' is set
        if ($mod_chat_get_chats_by_courses_request === null || (is_array($mod_chat_get_chats_by_courses_request) && count($mod_chat_get_chats_by_courses_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_chat_get_chats_by_courses_request when calling modScormGetScormsByCourses'
            );
        }


        $resourcePath = '/mod_scorm_get_scorms_by_courses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_chat_get_chats_by_courses_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_chat_get_chats_by_courses_request));
            } else {
                $httpBody = $mod_chat_get_chats_by_courses_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormInsertScormTracks
     *
     * Saves a scorm tracking record.                           It will overwrite any existing tracking data for this attempt.                           Validation should be performed before running the function to ensure the user will not lose any existing                           attempt data.
     *
     * @param  \OpenAPI\Client\Model\ModScormInsertScormTracksRequest $mod_scorm_insert_scorm_tracks_request mod_scorm_insert_scorm_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormInsertScormTracks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModScormInsertScormTracks200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormInsertScormTracks($mod_scorm_insert_scorm_tracks_request, string $contentType = self::contentTypes['modScormInsertScormTracks'][0])
    {
        list($response) = $this->modScormInsertScormTracksWithHttpInfo($mod_scorm_insert_scorm_tracks_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormInsertScormTracksWithHttpInfo
     *
     * Saves a scorm tracking record.                           It will overwrite any existing tracking data for this attempt.                           Validation should be performed before running the function to ensure the user will not lose any existing                           attempt data.
     *
     * @param  \OpenAPI\Client\Model\ModScormInsertScormTracksRequest $mod_scorm_insert_scorm_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormInsertScormTracks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModScormInsertScormTracks200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormInsertScormTracksWithHttpInfo($mod_scorm_insert_scorm_tracks_request, string $contentType = self::contentTypes['modScormInsertScormTracks'][0])
    {
        $request = $this->modScormInsertScormTracksRequest($mod_scorm_insert_scorm_tracks_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModScormInsertScormTracks200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModScormInsertScormTracks200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModScormInsertScormTracks200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ModScormInsertScormTracks200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModScormInsertScormTracks200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormInsertScormTracksAsync
     *
     * Saves a scorm tracking record.                           It will overwrite any existing tracking data for this attempt.                           Validation should be performed before running the function to ensure the user will not lose any existing                           attempt data.
     *
     * @param  \OpenAPI\Client\Model\ModScormInsertScormTracksRequest $mod_scorm_insert_scorm_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormInsertScormTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormInsertScormTracksAsync($mod_scorm_insert_scorm_tracks_request, string $contentType = self::contentTypes['modScormInsertScormTracks'][0])
    {
        return $this->modScormInsertScormTracksAsyncWithHttpInfo($mod_scorm_insert_scorm_tracks_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormInsertScormTracksAsyncWithHttpInfo
     *
     * Saves a scorm tracking record.                           It will overwrite any existing tracking data for this attempt.                           Validation should be performed before running the function to ensure the user will not lose any existing                           attempt data.
     *
     * @param  \OpenAPI\Client\Model\ModScormInsertScormTracksRequest $mod_scorm_insert_scorm_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormInsertScormTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormInsertScormTracksAsyncWithHttpInfo($mod_scorm_insert_scorm_tracks_request, string $contentType = self::contentTypes['modScormInsertScormTracks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModScormInsertScormTracks200Response';
        $request = $this->modScormInsertScormTracksRequest($mod_scorm_insert_scorm_tracks_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormInsertScormTracks'
     *
     * @param  \OpenAPI\Client\Model\ModScormInsertScormTracksRequest $mod_scorm_insert_scorm_tracks_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormInsertScormTracks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormInsertScormTracksRequest($mod_scorm_insert_scorm_tracks_request, string $contentType = self::contentTypes['modScormInsertScormTracks'][0])
    {

        // verify the required parameter 'mod_scorm_insert_scorm_tracks_request' is set
        if ($mod_scorm_insert_scorm_tracks_request === null || (is_array($mod_scorm_insert_scorm_tracks_request) && count($mod_scorm_insert_scorm_tracks_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_insert_scorm_tracks_request when calling modScormInsertScormTracks'
            );
        }


        $resourcePath = '/mod_scorm_insert_scorm_tracks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_insert_scorm_tracks_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_insert_scorm_tracks_request));
            } else {
                $httpBody = $mod_scorm_insert_scorm_tracks_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormLaunchSco
     *
     * Trigger the SCO launched event.
     *
     * @param  \OpenAPI\Client\Model\ModScormLaunchScoRequest $mod_scorm_launch_sco_request mod_scorm_launch_sco_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormLaunchSco'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormLaunchSco($mod_scorm_launch_sco_request, string $contentType = self::contentTypes['modScormLaunchSco'][0])
    {
        list($response) = $this->modScormLaunchScoWithHttpInfo($mod_scorm_launch_sco_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormLaunchScoWithHttpInfo
     *
     * Trigger the SCO launched event.
     *
     * @param  \OpenAPI\Client\Model\ModScormLaunchScoRequest $mod_scorm_launch_sco_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormLaunchSco'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormLaunchScoWithHttpInfo($mod_scorm_launch_sco_request, string $contentType = self::contentTypes['modScormLaunchSco'][0])
    {
        $request = $this->modScormLaunchScoRequest($mod_scorm_launch_sco_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormLaunchScoAsync
     *
     * Trigger the SCO launched event.
     *
     * @param  \OpenAPI\Client\Model\ModScormLaunchScoRequest $mod_scorm_launch_sco_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormLaunchSco'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormLaunchScoAsync($mod_scorm_launch_sco_request, string $contentType = self::contentTypes['modScormLaunchSco'][0])
    {
        return $this->modScormLaunchScoAsyncWithHttpInfo($mod_scorm_launch_sco_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormLaunchScoAsyncWithHttpInfo
     *
     * Trigger the SCO launched event.
     *
     * @param  \OpenAPI\Client\Model\ModScormLaunchScoRequest $mod_scorm_launch_sco_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormLaunchSco'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormLaunchScoAsyncWithHttpInfo($mod_scorm_launch_sco_request, string $contentType = self::contentTypes['modScormLaunchSco'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
        $request = $this->modScormLaunchScoRequest($mod_scorm_launch_sco_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormLaunchSco'
     *
     * @param  \OpenAPI\Client\Model\ModScormLaunchScoRequest $mod_scorm_launch_sco_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormLaunchSco'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormLaunchScoRequest($mod_scorm_launch_sco_request, string $contentType = self::contentTypes['modScormLaunchSco'][0])
    {

        // verify the required parameter 'mod_scorm_launch_sco_request' is set
        if ($mod_scorm_launch_sco_request === null || (is_array($mod_scorm_launch_sco_request) && count($mod_scorm_launch_sco_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_launch_sco_request when calling modScormLaunchSco'
            );
        }


        $resourcePath = '/mod_scorm_launch_sco';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_launch_sco_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_launch_sco_request));
            } else {
                $httpBody = $mod_scorm_launch_sco_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modScormViewScorm
     *
     * Trigger the course module viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModScormViewScormRequest $mod_scorm_view_scorm_request mod_scorm_view_scorm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormViewScorm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function modScormViewScorm($mod_scorm_view_scorm_request, string $contentType = self::contentTypes['modScormViewScorm'][0])
    {
        list($response) = $this->modScormViewScormWithHttpInfo($mod_scorm_view_scorm_request, $contentType);
        return $response;
    }

    /**
     * Operation modScormViewScormWithHttpInfo
     *
     * Trigger the course module viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModScormViewScormRequest $mod_scorm_view_scorm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormViewScorm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function modScormViewScormWithHttpInfo($mod_scorm_view_scorm_request, string $contentType = self::contentTypes['modScormViewScorm'][0])
    {
        $request = $this->modScormViewScormRequest($mod_scorm_view_scorm_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modScormViewScormAsync
     *
     * Trigger the course module viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModScormViewScormRequest $mod_scorm_view_scorm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormViewScorm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormViewScormAsync($mod_scorm_view_scorm_request, string $contentType = self::contentTypes['modScormViewScorm'][0])
    {
        return $this->modScormViewScormAsyncWithHttpInfo($mod_scorm_view_scorm_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modScormViewScormAsyncWithHttpInfo
     *
     * Trigger the course module viewed event.
     *
     * @param  \OpenAPI\Client\Model\ModScormViewScormRequest $mod_scorm_view_scorm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormViewScorm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modScormViewScormAsyncWithHttpInfo($mod_scorm_view_scorm_request, string $contentType = self::contentTypes['modScormViewScorm'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoreCalendarDeleteSubscription200Response';
        $request = $this->modScormViewScormRequest($mod_scorm_view_scorm_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modScormViewScorm'
     *
     * @param  \OpenAPI\Client\Model\ModScormViewScormRequest $mod_scorm_view_scorm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modScormViewScorm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modScormViewScormRequest($mod_scorm_view_scorm_request, string $contentType = self::contentTypes['modScormViewScorm'][0])
    {

        // verify the required parameter 'mod_scorm_view_scorm_request' is set
        if ($mod_scorm_view_scorm_request === null || (is_array($mod_scorm_view_scorm_request) && count($mod_scorm_view_scorm_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mod_scorm_view_scorm_request when calling modScormViewScorm'
            );
        }


        $resourcePath = '/mod_scorm_view_scorm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mod_scorm_view_scorm_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mod_scorm_view_scorm_request));
            } else {
                $httpBody = $mod_scorm_view_scorm_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
